-------------------------------
--        TATT - DM2         --
-- Paul BERTHELOT - SRS 2026 --
-------------------------------

1. Voici la commande que j'ai utilisé pour trouver les occurences d'appels aux
   fonctions de la famille printf, ne contenant pas de '%' :

   grep -E -n "\b(printf|fprintf|sprintf|snprintf|dprintf|vprintf|vfprintf|vsprintf|vsnprintf|vdprintf)\s*\([^\"]*[a-zA-Z_][a-zA-Z0-9_]*[^,\)]*\)" --include="*.c" -r .

   qui nous donne:

   ./src/ufile.c:18:  fprintf(stderr, s);
   ./src/ufile.c:38:  printf(s);
   ./src/main.c:84:  printf(msg);
   ./src/main.c:117:    fprintf(ftp->log_f, banner);

   On peut voir que la seule occurence d'un appel à ces fonctions qui puisse
   être exploitable (`printf(variable)` dans `%s`, où la variable peut être
   modifiée par un input utilisateur) est dans `main.c`, ligne 117:

   fprintf(ftp->log_f, banner);

   Le code lit le fichier banner.txt, puis le print sur stdout.

   La condition pour que cette ligne s'execute est que le programme soit lancé
   avec l'option `-v` set différent de 0 (exemple: 1). Evidedmment, il faut
   avoir accès en écriture au fichier `banner.txt`.

2. Pour trouver le numéro de l'argument correspondant au buffer dans la pile,
   ma méthode a été de tester l'injections de plusieurs valeurs successives
   dans le fichier banner.txt avec des valeurs reconnaissable au début du buffer
   (ABCD). J'ai utilisé ce script shell:

   #!/bin/bash
   for i in $(seq 1 20); do
     echo "ABCD%$i\$x" > banner.txt
     echo "Test avec offset $i"
     ./my_ftpd -v 1 -u users.txt
   done

   Initialement, avec l'offset 4, j'ai obtenu "ABCD434241c0", ce qui indique un
   problème d'alignement dans la pile, car la représentation hexadécimale de
   "ABCD" devrait être "41424344".

   Pour corriger l'alignement, j'ai ajouté 3 octets de padding ("000") devant
   ma chaîne de test et incrémenté l'offset d'une unité, utilisant ainsi
   "000ABCD%5$x". Cette modification a permis d'obtenir "ABCD44434241", où
   "44434241" est la représentation hexadécimale de "ABCD" en little-endian.

   Le numéro de l'argument de la fonction fprintf correspondant au buffer dans
   la pile est donc 5.

3. Pour obtenir l'adresse à modifier avec la vulnérabilité que l'on vient de
   trouver, il faut définir une cible pertinente dans la mémoire du programme.
   Dans le cas des format string bug, c'est généralement :

   - Les entrées de la Global Offset Table (GOT) : tableau utilisé pour résoudre
     les adresses des fonctions des bibliothèques partagées
   - Les destructeurs (DTOR) de la libc : fonctions exécutées à la fin du
     programme

   Je pense que la méthode la plus efficace dans notre cas est de choisir une
   entrée de la GOT correspondant à une fonction qui sera appelée après notre
   point d'exploitation.

   Pour identifier ces adresses, j'ai utilisé la commande `objdump -R my_ftpd`,
   qui nous permet d'obtenir les adresses des différents éléments de cette
   table.

   Plus précisément en faisant cette fonction on peut voir l'adresse de fputc:

   $ objdump -R my_ftpd | grep fputc
   080970bc R_386_JUMP_SLOT   fputc@GLIBC_2.0

   Car j'ai choisi de cibler l'adresse de `fputc@GLIBC_2.0` à l'adresse
   `0x080970bc` car cette fonction est appelée dans la fonction vulnérable que
   nous avons identifiée (`main.c`, ligne 118), juste après notre exploitation
   de la vulnérabilité. Nous pourrons ensuite la remplacer par l'adresse de
   notre shellcode.

   J'avais au départ essayé de cibler l'adresse de `fprintf` car c'est la
   fonction qui est appelée dans le code C, mais le compilateur l'a remplacé
   par `fputc`, étant donné qu'un seul caractère est écrit.

4. Premièrement, j'ai désactivé l'ASLR avec la commande suivante :

   echo 0 > /proc/sys/kernel/randomize_va_space

   Ensuite, pour calculer l'adresse du shellcode dans l'environnement, j'ai
   procédé comme dans la section 5.1.2 du cours. J'ai simplement appliqué la
   formule du cours, avec comme chemin du programme : `./my_ftpd`:

   adresse_shellcode = 0xc0000000
                       - 4
                       - strlen('./my_ftpd')
                       - 1
                       - strlen(SHELLCODE) - 1

   Ce qui, avec mon shellcode, donne l'adresse 0xbfffffda.

5. Maintenant que l'on a les adresses de la fonction `fputc` et de notre
   shellcode, il ne reste plus qu'à construire le payload.
   Nous voulons donc écrire à l'adresse de `fputc` (0x080970bc) l'adresse du
   shellcode (0xbfffffda), pour que lors du prochain appel à `fputc`, le
   programme exécute notre shellcode.

   Pour écrire l'adresse 0xbfffffda à l'adresse 0x080970bc, j'utilise la
   technique d'écriture en deux parties avec %hn qui permet d'écrire deux
   octets à la fois:
   - octets bas (0xffda) à l'adresse 0x080970bc
   - octets haut (0xbfff) à l'adresse 0x080970be

   Ma chaîne de format sera donc composée de :
   - `000` : trois octets de padding pour s'aligner sur la pile (cf question 2)
   - `\xbc\x70\x09\x08` : Adresse de la GOT pour fputc (octets de poids faible)
   - `\xbe\x70\x09\x08` - Adresse de la GOT+2 (octets de poids fort)
   - `%65487x` : affiche 65487 caractères de remplissage :
       0xffda - 3 (padding) - 8 (adresses de la GOT) = 65487
   - `%5$hn` : écrit le nombre de caractères affichés (0xffda) à l'adresse
      0x080970bc.
   - `%49189x` : affiche 49189 caractères de remplissage :
      0x1bfff - 0xffda = 49189 avec un dépassement à 0x10000 car 0xbfff < 0xffda
   - `%6$hn` : écrit le nombre total de caractères affichés modulo 65536 (0xbfff)
      à l'adresse 0x080970be.

   Ce qui donne : `000\xbc\x70\x09\x08\xbe\x70\x09\x08%65487x%5$hn%49189x%6$hn`.

   L'exploit final est dans le fichier `2fsb_exploit.c`.